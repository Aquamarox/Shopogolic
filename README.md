# Отчет по проекту: Микросервисная система «Gozon»
## Бабий Глеб сергеевич, БПИ248
## 1. Общее описание системы
Система представляет собой распределенную архитектуру для обработки заказов и платежей. Она спроектирована с учетом высоких нагрузок и требований к надежности финансовых операций. Взаимодействие между сервисами происходит асинхронно через брокер сообщений Kafka.

## 2. Архитектура и ключевые классы

### Orders Service (Сервис заказов — порт 8080)
Отвечает за прием заказов от пользователей и отслеживание их жизненного цикла.

- **Order**: Модель данных заказа со статусами (Created, PaymentPending, PaymentCompleted, PaymentFailed).
- **OrderEventSender**: Реализация паттерна Transactional Outbox. Сканирует таблицу сообщений и гарантированно отправляет их в Kafka.
- **PaymentResultConsumer**: Фоновый воркер, который слушает ответ от платежной системы и обновляет статус заказа.
- **OrderHub**: SignalR-хаб для связи с фронтендом через WebSockets.

### Payments Service (Сервис платежей — порт 8081)
Отвечает за баланс пользователей и проведение оплат.

- **Account**: Сущность счета пользователя.
- **OrderCreatedConsumer**: Реализует паттерн Transactional Inbox. Гарантирует, что каждый заказ будет обработан строго один раз (идемпотентность).
- **BalanceService**: Логика списания средств с использованием атомарных операций для предотвращения коллизий.

## 3. Межсервисное взаимодействие и паттерны
Для обеспечения надежности (семантика Exactly Once) в системе реализованы следующие механизмы:

- **Асинхронный поток**: Заказ создается мгновенно, а оплата происходит «в фоне». Это позволяет системе не «виснуть» в ожидании ответа от банка или другого сервиса.
- **Transactional Outbox**: Мы не отправляем сообщение в Kafka напрямую из контроллера. Мы сохраняем его в ту же БД, где лежит заказ. Если БД подтвердила транзакцию — сообщение гарантированно уйдет.
- **Идемпотентность**: При получении заказа Payments Service проверяет свой Inbox. Если такой ID заказа уже обрабатывался, система проигнорирует дубликат, не списывая деньги повторно.

## 4. Схема работы (Workflow)

1. **API**: Пользователь создает заказ через OrdersService.
2. **Event**: Заказ попадает в Kafka (топик `order-created`).
3. **Process**: PaymentsService списывает деньги и отправляет результат в топик `payment-processed`.
4. **Notify**: OrdersService ловит результат и через WebSocket мгновенно обновляет экран клиента.

## 5. Инструкция по запуску

### 1. Запуск окружения
Убедитесь, что Docker запущен, и выполните в корне проекта:

```bash
docker-compose up --build
```

### 2. Подготовка кошелька (Swagger 8081)
Для того чтобы оплата прошла успешно, создайте счет и пополните его:

- `POST /api/Accounts` с вашим `userId` (GUID).
- `POST /api/Accounts/{userId}/deposit` на сумму 1000.

### 3. Наблюдение (WebSocket)
Откройте в браузере: `http://localhost:8080/index.html`. Страница подключится к серверу и будет ждать обновлений.

### 4. Создание заказа (Swagger 8080)
Создайте заказ через `POST /api/Orders`.

**Важно**: используйте тот же `userId`, что и для кошелька. В качестве примера выбран be578685-7963-4876-8809-58b38342468f.
Если требуется заменить просматривоемого пользователя, укажите необходимое id в файле index.html (папка wwwroot).
